---
layout: post
category: 技术
title: 深入浅出搜索架构引擎、方案与细节（上）
---

**本文转自`58沈剑`的公众号：架构师之路**  

## 一、缘起
本文主要内容如下，本篇(上)会重点介绍前三章：   
（1）全网搜索引擎架构与流程  
（2）站内搜索引擎架构与流程  
（3）搜索原理、流程与核心数据结构  
（4）数据量由小到大，搜索方案的架构与变迁  
（5）数据量、并发量、数据扩展性与架构方案  
（6）实时搜索引擎核心技术  
  
## 二、全网搜索引擎架构与流程
全网搜索的宏观架构长啥样？  
全网搜索的宏观流程是什么样的？  

![](http://oon3ys1qt.bkt.clouddn.com/%E5%85%A8%E7%BD%91%E6%90%9C%E7%B4%A2%E5%AE%8F%E8%A7%82%E6%9E%B6%E6%9E%84.jpg)  

全网搜索的宏观架构如上图，核心子系统主要分成三部分(粉色部分)：  

1.spider爬虫系统

2.search&index建立索引与查询索引系统，这个系统主要分成两部分：  
  1) 一部分用于**生成索引数据**build_index  
  2) 一部分用于**查询索引数据**search_index  

3.rank打分排序系统  

核心数据主要分成两部分（紫色部分）：  

1.web网页库  

2.index索引数据

**全网搜索引擎的特点决定了，这是一个写入和检索完全分离的系统**。  

### 写入
**系统组成：** 由spider和search&index两个系统组成  

**输入：** 站长们生成的互联网网页  
 
**输出：** 正排倒排索引数据  

**流程：** 如架构图中的1，2，3，4  
  1) spider把互联网网页抓过来  
  2) spider把互联网网页存储到网络库中，这个对存储的要求很高，要存储整个万维网的网络镜像  
  3) build_index存网页库中读取数据，完成分词  
  4) build_index生成倒排索引  
### 检索
**系统组成：** 由search和index两个系统组成  

**输入：** 用户的搜索词  

**输出：** 排好序的第一页搜索结果

**流程：** 如架构图中的a,b,c,d  
  a)search_index获得用户的搜索词，完成分词  
  b）search_index查询倒排索引，获得字符匹配的网页，这是初筛的结果  
  c）rank对初筛的结果进行打分排序    
  d）rank对排序后的第一页结果返回  

## 三、站内搜索引擎架构与流程  

做权网上搜索的公司只是少数，大部分公司实际上只需要实现站内搜索就可以了，站内搜索引擎的宏观架构和全网搜索引擎的宏观架构有什么不同？  
以58同城100亿帖子的搜索为例，站内搜索引擎架构长啥样？站内搜索流程是什么样的？  

![](http://oon3ys1qt.bkt.clouddn.com/%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%AE%8F%E8%A7%82%E6%9E%B6%E6%9E%84.jpg)  

站内搜索引擎的宏观架构如上图，与全网搜索引擎的宏观架构相比，差异只有写入的地方：  

1）全网搜索引擎需要spider取被动抓取数据  

2）站内搜索是系统内部生成的数据，例如发布系统会将生成的帖子主动退给build_data系统。  

看似很小的差异，架构实现上难度却相差很多：**全网搜索如何“实时”的“发现”“全量”的网页是非常困难的**，而站内搜索容易实时得到全部数据。  

对于spider，search&index，rank三个系统：  
1）spider和search&index是相对工程的系统  
2）rank是和业务，策略和算法紧密相关的系统，搜索体验的差异主要在此，而业务和策略的优化是需要时间积累的，这里的启示是：  
a）google的体验比baidu好，根本在与前者的rank牛逼  
b）国内互联网公司（例如360）短时间要搞一个体验超过百度的引擎，是很难的，需要时间的积累。  

## 四、搜索原理与核心技术结构  
什么是正排索引?  

什么是倒排索引？  

搜索的过程是什么样的？  

会用到哪些算法与数据结构？

前面的内容太宏观，为了照顾大部分没有做过搜索引擎的同学，数据结构与算法部分从正排索引、倒排索引一点点开始。  

** 提问：什么是正排索引？(forward index)**   

** 回答：  由key查询实体的过程，就是正排。**   
用户表： t_user(uid,name,passwd,age,sex), 由uid查询整体的过程，就是正排索引。  

网页内容分词后，page_content会有一个分词后的集合**List<item>**  

简易的，**正排**索引可以理解为Map<url,list<item>>,能够由**网页**快速(时间复杂度O(1))找到内容的一个数据结构；  


**提问：什么是倒排索引(inverted index)?**  

**回答：由item查询key的过程，就是倒排索引。**  

对应网页搜索，**倒排**索引可以理解为Map<item,list<url>>,能够由**查询词**快速(时间复杂度O(1))找到包含这个查询词的网页内容的一种数据结构。  

举个例子，假设有三个网页：  
url1 -> "我爱北京"  
url2 -> '我爱到家'  
url3 -> '到家美好'  
这是一个正排索引Map<url,page_content>  

分词之后：  
url1 -> {我，爱，北京}  
url2 -> {我，爱，到家}  
url3 -> {到家，美好}  
这是一个分词后的正排索引Map<url,list<item>>  

分词后的倒排索引：  
我 -> {url1,url2}     
爱 -> {url1,url2}   
北京 -> {url1}  
到家 -> {url2, url3}  
美好 -> {url3}  
由检索词快速找到包含这个查询词的网页Map<item,list<url>>就是倒排索引。   

正排索引和倒排索引是spider和build_index提前建立好的数据结构，为什么要使用这两种数据结构，是因为它能够快速的实现**用户的网页检索**的这个需求。  

**提问： 搜索的过程是什么样的？**  

假设搜索词是“我爱”，用户会得到什么网页呢？  
1）分词，“我爱”会分成“我”和“爱”，时间复杂度为O（1）  
2）每个分词后的item，搜索倒排索引得到包含这个item的网页list<url>,时间复杂度也是O(1)  
我 -> {url1，url2}  
爱 -> {url1,url2}  
3）求list<url>的交集，也就是符合所有查询词的结果网页，对于这个例子，{url1,url2}就是最终的查询结果。  

看似到这里就结束了，其实不然，分词和倒排查询的时间复杂度都是O(1),整个搜索的时间复杂度取决于“求list<url>的交集",**问题简化为了求两个集合的交集。**  

字符型的url不利于存储于计算，**一般来说每个url会有一个数值型的url_id来标识**，后文为了方便描述，list<url>改成list<url_id>。  

**list1 和list2，求交集怎么求？**  

**方案一：** for \* for 土办法，时间复杂度O(n\*n) ,每个搜索词命中的网页是很多的，O(n\*n)的时间复杂度显然是不能够接受的。 **倒排索引在建立之初可以进行预排序处理**，所以问题可以转化成两个有序list的交集，就方便多了。  

**方案二**： 有序list求交集，**拉链法**   

![](http://oon3ys1qt.bkt.clouddn.com/%E6%8B%89%E9%93%BE%E6%B3%95%E6%B1%82%E4%BA%A4%E9%9B%86.jpg)  

有序集合1{1，3，5，7，8，9}   
有序集合2{2, 3, 4, 5, 6, 7}
两个指针指向首元素，比较元素 的大小：  
1)如果相同，放入结果集，移动两个指针；  
2）否则，移动较小的一个指针，直到队尾  

这种方法的好处是：  
1）集合中的元素最多比较一次，时间复杂度O(n)  
2) 多个有序集合可以并行，适用于多个分词item求url_id的交集  

这个方法就像一个拉链的两个齿轮，一一比对就像拉链，故称为拉链法。  

**方案三：分桶并行优化**  

数据量大时，url_id分桶水平切分+并行运算是一种常见的优化方法，如果将list1<url_id>和list2<url_id>分成若干个桶区间，每个区间利用多线程并行求**交集**，各个线程结果集的**并集**，作为最终的结果集，能够大大的减少运行时间。  

举例：  
有序集合1{1,3,5,7,8,9,10,30,50,70,80,90}   
有序集合2{2,3,4,5,6,7,20,30,40,50,60,70}  
求交集，先进行分桶拆分：  
桶1的范围为[1,9]  
桶2的范围为[10,100]  
桶3的范围为[101,max]  

于是，  
集合1拆分成：   
集合a{1,3,5,7,8,9}  
集合b{10,30,50,70,80,90}  
集合c{}  

集合2拆分成：  
集合d{2，3，4，5，6，7}  
集合e{20，30，40，50，60，70}  
集合f{}  

每个桶内的数据量大大降低了，并且每个桶内没有重复元素，可以利用多线程进行计算：  
桶1内的集合a和桶1内的集合d的交集是x{3，5，7}  
桶2内的集合b和桶2内的集合e的交集是y{30，50，70}  
桶3内的集合c和f交集是z{}  

最终集合1和集合2的交集，是x,y,z的并集：{3,5,7,30,50,70}  

**方案四： bitmap再次优化**  

数据进行了水平桶拆分之后，每个桶内的数据一定处于一个范围之内，如果集合符合这个特点，就可以使用bitmap来表示集合：  

![](http://oon3ys1qt.bkt.clouddn.com/bitmap%E6%B1%82%E4%BA%A4%E9%9B%86.jpg)  

如上图，，假设set1{1,3,5,7,8,9}和set2{2,3,4,5,6,7}的所有元素都在桶值[1, 16]的范围之内，可以用16个bit来描述这两个集合，原集合中的元素x，在这个16bitmap中的第x个bit为1，此时两个bitmap求交集，只需要将两个bitmap进行“与”操作，结果集bitmap的3，5，7位是1，表明原集合的交集为{3,5,7}。   

水平分桶，bitmap优化之后，能极大提高求交集的效率，但时间复杂度仍旧是O(n)  
bitmap需要大量连续空间，占用内存较大  

**方案五：跳表skiplist**  

有序链表集合求交集，跳表是最常用的数据结构，它可以将有序集合求交集的复杂度由O(n)降至O(log(n))

![](http://oon3ys1qt.bkt.clouddn.com/%E6%8B%89%E9%93%BE%E6%B3%952.png)  

集合1{1,2,3,4,20,21,22,23,50,60,70}   
集合2{50,70}   
要求交集，如果用拉链法，会发现1,2,3,4,20,21,22,23都要被无效遍历一次，每个元素都要被比对，时间复杂度为O(n)，能不能每次比对“跳过一些元素”呢？   

跳表就出现了：  

![](http://oon3ys1qt.bkt.clouddn.com/%E8%B7%B3%E8%A1%A8.png)  

集合1{1,2,3,4,20,21,22,23,50,60,70}建立跳表时，一级只有{1,20,50}三个元素，二级与普通链表相同   
集合2{50,70}由于元素较少，只建立了一级普通链表

如此这般，在实施“拉链”求交集的过程中，set1的指针能够由1跳到20再跳到50，中间能够跳过很多元素，无需进行一一比对，跳表求交集的时间复杂度近似O(log(n))，这是搜索引擎中常见的算法。  

## 五、总结

文字很多，有宏观，有细节，对于大部分不是研究搜索引擎的同学，记住下面的即可：  

1） 全网搜索引擎有spider，search&index,rank三个子系统组成  
2） 站内搜索引擎与全网搜索引擎的差异在与，少了一个spider系统  
3） spider和search&index系统是两个工程系统，而rank系统的优化却需要长时间的积累。  
4） 正排索引（forward index）是由网页url_id找到分词后的网页内容List<item>的过程  
5） 倒排索引（inverted index）是由分词item快速查找包含这个分词的网页list<url_id>的过程  
6） 用户检索的过程，是先分词，再找到每个item对应的list<url_id>,然后求交集，得到最后的list<url_id>的过程  
7） 有序集合求交的方法有：    
    a) 二重for循环    O(n\*n)
    b）拉链法   O(n)
    c）跳表   O(log(n))
    d）水平分桶，多线程并行   
    e）bitmap，O(n) 

