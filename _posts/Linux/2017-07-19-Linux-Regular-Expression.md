---
layout: post
category: Linux
title: Linux下的通配符和正则表达式
---

**本文梳理一下linux下的通配符和正则表达式用法**  
## 概念
先梳理概念，linux下的特殊符号的概念主要有三种，对于不同的概念，同一个字符可能代表着完全不同的意思，为了避免混淆，先建立一个简单的概念抽象：  
通配符(wildcard)是bash提供的一个很方便的功能，可以用简单的字符代表特定的操作。
  
特殊符号是bash中定义的代表特定意思的符号，概念上和通配符很相似，但是它与通配符的区别就是通配符定义的符号主要作用在于一个"通"字，表示一个字符，可以代表很多个对象，或者是重复的内容，或者是顺序递归的内容等等；而特殊符号更像是bash给自己预留的满足命令行的基本功能的一些符号。

正则表达式(Regular Expression)是一种表达方式，它不仅仅依赖于bash，只要是支持其表达模式的工具都可以使用正则来进行文本处理和命令的简化，常见的支持正则的linux下的工具有grep，sed，awk，vi，vim，python的re模块等等。

**简单区别通配符和正则表达式：**通配符多用于命令行，或者文件名，正则表达式用于文本内容的处理。
## 通配符
通配符的作用就是返回满足符号规定条件的结果，通常用于ls，cat等命令中。

符号|功能
:---:|---
*|代表0到无穷多个的任意字符
?|代表有且仅有一个任意字符
[]|代表一定有一个括号内的指定字符(非任意字符)，例如[abcd]代表一定有一个字符，可能是a,b,c,d中的任意一个
[-]|若有减号在括号内时，代表在编码顺序内的所有字符。例如[1-9]代表从1到9内的所有数字，因为数字的语系编码是连续的
[^]|若中括号里的第一个字符为^,则表示反向选择。例如[^abc]代表一定有一个字符，只要是非a,b,c的其他字符就接受

举例：
```shell
找出/etc下一cron位开头的文件名：
ls /etc/cron*

找出/etc/下文件名刚好为五个字符的文件:
ls /etc/?????

找出/etc/下文件名含有数字的文件:
ls /etc/*[0-9]*

找出/etc/下文件名开头为非小写字母的文件：
ls /etc/[^a-z]*

批量复制文件到/tmp中：
cp -a /etc/[^a-z]* /tmp

批量查看文件:
ls /opt/config/servers/*/mods
/opt/config/servers/0-0-1/mods:
BILL  DGR  RTDB  SUBMEAS  VXPROC

/opt/config/servers/0-0-10/mods:
BILLHPR  CORCMON  DGR  MATESCH  SPADBI  SUBMEAS  VXPROC
```


## 特殊符号
特殊符号实际上和通配符很相似，归为一类也未尝不可，因为它和通配符没有任何符号被重用。

符号|功能
:---:|---
\#|批注符号，常用在脚本中，其后的内容不被执行
\ |转义符号，将“特殊字符或通配符”还原成一般字符
丨|管道(pipe)，分割两个管道命令的界定，或者说是连接两个管道命令，使前面的命令标准输出，传递给后面管道命令的标准输入(标准错误输出会被忽略)
;|连续执行命令的分隔符，可以一行内执行多条命令
~|用户的主文件夹(家目录)
$|变量前导符，使用变量时必须要加的符号
&|作业控制(job control)，将命令调到后台工作
!|逻辑运算上“非”的意思
/|目录符号
\>,\>\>|数据流重定向，输出导向，分别是替换和累加
<,<<|数据流重定向，输入导向，分别是从文件输入和带截止符号的输入
' '|单引号，不具备变量替换的功能，即内部元素全当做字符串
""|双引号，具备变量替换的功能，能识别内部的变量，并将其替换成变量值
``|反引号，表示内部的命令先执行，也可以使用$()将命令包含进去，推荐后者
()|在中间为子shell的起始和结束
{}|在中间为命令块的组合

## 正则表达式
Linux Shell环境下提供了两种正则表达式规则，一个是基本正则表达式(BRE)，另一个是扩展正则表达式(ERE)。下表列出两种正则表达式规则下的语法和字符意义：  
**首先列出BRE和ERE都有的字符：**

正则元字符|模式含义|例子
:---:|---|---
\\| 打开或关闭后续字符的特殊意义，或称转义|\(...\)这里括号仅表示括号字符
.|匹配任意单个字符(包括空格)|a.b将匹配acb,abb等
*|匹配其前面字符任意次(0-n次)| a＊b匹配ab,aab,aaab等
.*|匹配任意字符任意次|a＊b匹配ab,asb,afferdb等等
^|从行的起始处匹配^号后面的内容|^abc能匹配到abcdef, abckk等
$|从行的末尾处匹配$号前面的内容|hei$能匹配到abchei,whathei等
[]|方括号，里面的内容不论有几个字符，只代表匹配一个字符。 <br> "^"在方括号里面表示反向选择<br>"-"在方括号里面表示匹配连续字符中的任意一个|a[^a]c能匹配出abc,adc,但是不能匹配出aac; <br>t[ea]st匹配出test和tast，但不能匹配teast；<br>a[0-9]匹配出a0，a1等等；<br>a[0-9a-zA-Z]匹配a后面有数字或者大小写字母的所有项:a0,aa,aZ等

**仅在BRE中支持的字符：**

正则元字符|模式含义|例子
:---:|---|---
\\{n,m\\}|匹配其前面字符的次数区间n到m次|ab\\{2\\}仅匹配abb<br>ab\\{2,\\}匹配abb，abbb，abbbb等<br>ab\{2,4\}匹配abb，abbb和abbbb
\\(...\\)|字符串组(子模式)，可以将括号内的字符串作为一个整体来匹配，并保存比配的文本|\\(abc\\)\\(df\\)可以匹配到abcdf<br>\\(abc\\)\\{2\\}可以匹配到abcabc
\n|和\(...\)配合使用，表示第n个组(子模式)|\1表示第一组，(abc).*\1可以匹配开头和结尾都是abc的字符串：abcdfdabc或abcabc；<br>(abc)\1\1可以匹配abcabcabc；同理如果有第二个括号，可以用\2表示


**仅在ERE中支持的字符：**

正则元字符|模式含义|例子
:---:|---|---
+|匹配其前面字符1到n次|ab+能匹配ab，abb,abbb但不能匹配a
?|匹配其前面字符0次或1次|ab?仅匹配a和ab
｜|用或(or)的方式匹配字符串|"oo｜ee"可以匹配到任何包含oo或者ee的字符串
()|括号同BRE，写法不同|同上(BRE)，写法不同
()+|匹配组重复多次|"A(xy)+C"可以匹配"AxyxyxyxyC"等
{n,m}|同上\\{...\\}，在扩展表达式中不用加转义字符\|同上(BRE)，写法不同

**还有一些特殊符号，是为了避免语系不同导致编码方式不同导致的符号歧义**：  
举例：在对大小写英文字母的编码时，zh_CN.big5 和C 语系的输入如下：   
LANG=C时： ABCD...Zabcd...z   
LANG=zh_CN.big5时：aAbBcCdD...zZ   
这会导致正则符号[a-z]在同语系下得到的返回结果不同，所以有一种通用的符号来避免混乱：  

特殊符号|代表意义
:---:|---|---
`[:alnum:]`|代表英文大小写字母及数字，即0-9，A-Z,a-z
`[:alpha:]`|代表任何英文大小写字母,即A-Z,a-z
`[:blank:]`|代表空格和[Tab]键
`[:cntrl:]`|代表键盘上面的控制按键，即包括CR,LF,Tab,Del等
`[:digit:]`|代表数字，0-9
`[:graph:]`|代表除了空格符(空格和Tab)之外的其他所有按键
`[:lower:]`|代表小写字符，即[a-z]
`[:print:]`|代表任何可以被打印出来的字符
`[:punct:]`|代表标点符号(punctuation symbol), 即"'?!;:#$
`[:upper:]`|代表大写字符，A-Z
`[:space:]`|代表任何会产生空白的字符，空格键[Tab]键和CR等
`[:xdigit:]`|代表十六进制的数字类型，因此包括0-9,A-F,a-f的数字与字符

需要注意到是，在grep中使用上述特殊符号时，需要将其用[]括起来，例如：`[[:digit:]]`

##在shell中正则的使用
在shell中，正则表达式常常通过如下几个命令实现(这里不做展开，单独命令的用法见我的其它文章)：  

**grep:**   
grep默认支持基础正则，如果想支持扩展正则，需要加"-E"参数，或者使用egrep命令实现同样的功能。

**sed:**  
sed工具默认支持基础正则，加-r参数可以支持扩展正则。

**awk:**  
awk严格说可以算是一种语言了，有自己的语法和格式，试验得到支持扩展正则，留待以后整理。

## 补充点零宽断言的用法
在shell中，经常会遇到这种情况：  
在如下字符串中：  
`http://2.20.16.61:12000/?key=%CA%D6%BB%FA&pagesize=120&enc_url_gbk`  

想要拿到key=后面的key的值，但是不需要`key=`这几个字符，我们用python的group很容易拿到：  
```python
>>> import re
>>> a = 'http://2.20.16.61:12000/?key=%CA%D6%BB%FA&pagesize=120&enc_url_gbk'
>>> re.search(r'key=(.*?)&',a).group()
'key=%CA%D6%BB%FA&'
>>> re.search(r'key=(.*?)&',a).group(1)
'%CA%D6%BB%FA'
```

用shell的话，**sed**可以通过替换字符串

```hell
$ str='http://2.20.16.61:12000/?key=%CA%D6%BB%FA&pagesize=120&enc_url_gbk'
$ echo $str |sed 's/.*key=//'|sed 's/&.*//'
%CA%D6%BB%FA
```

但是用**grep**的话，就只能使用零宽断言了，因为正常的使用正则的话只能把`key=`一起匹配上：
```shell
$ echo $str |grep -Po 'key=.*?&'
key=%CA%D6%BB%FA&
```
使用零宽断言里的正向回顾断言的语法可以搞定`(?<=exp)`
```shell
echo $str |grep -Po '(?<=key=).*?&'
%CA%D6%BB%FA&
```
**零宽断言详细解释： [百度百科-零宽断言](https://baike.baidu.com/item/%E9%9B%B6%E5%AE%BD%E6%96%AD%E8%A8%80)**  

**简单总结零宽断言：**  
零宽断言分两大类：正向和负向，简单理解正向就是匹配有的，负向就是匹配没有的(类似与正则里的`^`符号)  
  
每一类又分预测零宽断言和回顾零宽断言，简单理解就是定义的断言字符串在前面--就是回顾，在后面--就是预测

**举例:**  

名称|reg|举例
---|---|---
正回顾后发|(?<=reg)|echo key=123｜grep -Po '(?<=key=).*', 输出123
正预测先行|(?=reg)|echo key=123｜grep -Po '.*(?==123)', 输出key
负回顾后发|(?<!exp)|echo "key1 Key2"｜grep -Po '(?<!k)ey.',输出ey2
负预测先行|(?!exp)|echo "key1 Key2"｜grep -Po '.*y(?!2)'

话说这都什么反人类的名字，就正(负)回顾,正(负)预测就完了呗
