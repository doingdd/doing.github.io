<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" /> <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]--> <meta name="author" content="doing"> <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,400italic,600|Droid+Sans+Mono' rel='stylesheet' type='text/css'> <link rel="shortcut icon" href="https://raw.githubusercontent.com/doingdd/img/master/dd.png" /> <link rel="stylesheet" href="/css/main.css"> <link rel="canonical" href="http://localhost:4000/2017/04/20/Python-practice-value-and-copy.html"> <!-- Begin Jekyll SEO tag v2.2.2 --> <title>Python知识点 – 变量赋值与深浅copy | doing blog</title> <meta property="og:title" content="Python知识点 – 变量赋值与深浅copy" /> <meta name="author" content="doing" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="本系列列举一些常见的Python知识点，本文涉及变量的赋值，存储和深浅拷贝。 首先上结论： 赋值，浅拷贝，深拷贝中，源数据和目标数据的相关性为 赋值 &lt; 浅copy &lt; 深copy 赋值：a = b，a和b只是名字不同，内容完全共同变化。 copy： 浅拷贝的第一层不共同变化，如果有嵌套list，则嵌套部分共同变化。 deepcopy： 深拷贝所有内容完全独立，无共同变化。 1. 先举例，请解释输出的原理 [root@localhost mystuff]# cat it01.py ## explain follow return value of list and why? def extendList(val, list = []): list.append(val) return list list1 = extendList(10) list2 = extendList(123, []) list3 = extendList(&#39;a&#39;) print &quot;list1 = %s&quot; % list1 print &quot;list2 = %s&quot; % list2 print &quot;list3 = %s&quot; % list3 [root@localhost mystuff]# python it01.py list1 = [10, &#39;a&#39;] list2 = [123] list3 = [10, &#39;a&#39;] 首先解释为什么list3是[10， ‘a’] 而不是 [‘a’]。因为函数extendList的参数默认值：list = []只有在函数被定义的时候（或者第一次调用的时候？）定义一次，如果继续进行函数调用，函数参数的默认值是不进行定义的，因为这时候这个参数已经有了值，无论这个值是否被改变，它都已经固定了，当然这是不给函数传递参数的前提下。 然后解释为什么list1会随着list3的赋值而变化。这里涉及到python变量存储和深浅copy的知识如下： 参考Eva_J的博客 python的变量存储 python中变量的存储采用引用语义的方式，存储的只是一个变量的值所在的内存地址，而不是变量的值本身。 顺便提一下，C语言不是这种方式，是值语义，即变量存储的就是一个值本身。 所以，python变量的大小都是一样的，因为内存地址的大小一致。而C语言的变量大小是不固定的。 python中一切皆对象，即使不同的变量类型， 本质上也都是存储地址，如下图： 数据初始化对内存地址的影响 变量每一次初始化， 都开辟了一个新空间，然后将新内容的新地址赋给变量： &gt;&gt;&gt; st1 = &quot;Hello World.&quot; &gt;&gt;&gt; print id(st1) 139715299268008 &gt;&gt;&gt; st1 = &quot;to be&quot; &gt;&gt;&gt; print id(st1) 139715299265296 等等，不同内容的地址肯定是不一致的，但是相同内容的地址就一定一致么？答案是no： &gt;&gt;&gt; st1 = &quot;Hello World.&quot; &gt;&gt;&gt; print id(st1) 139715299268008 &gt;&gt;&gt; st2 = &quot;Hello World.&quot; &gt;&gt;&gt; print id(st2) 139715299268064 再等等，那相同内容的地址，肯定也不一致么，那岂不是浪费很多内存空间？答案还是no： &gt;&gt;&gt; st1 = 123 &gt;&gt;&gt; st2 = 123 &gt;&gt;&gt; print id(st1), id(st2) 34236496 34236496 &gt;&gt;&gt; st1 = 123456123 &gt;&gt;&gt; st2 = 123456123 &gt;&gt;&gt; print id(st1), id(st2) 34569208 34569016 找不到规律，目前唯一能确定的是：不同内容的内存地址是不一样的,而且，对简单数据结构(string)的重新初始化，会使内存地址变动 &gt;&gt;&gt; st1 = 123 &gt;&gt;&gt; st2 = st1 &gt;&gt;&gt; print id(st1), id(st2) 34236496 34236496 &gt;&gt;&gt; st1 = 456 &gt;&gt;&gt; print &quot;st1: %d, st1 address: %d&quot; % (st1, id(st1)) st1: 456, st1 address: 34569208 &gt;&gt;&gt; print &quot;st2: %d, st2 address: %d&quot; % (st2, id(st2)) st2: 123, st2 address: 34236496 数据结构内部元素的变化对内存地址的影响 &gt;&gt;&gt; lst1 = [1, 2, 3, &#39;a&#39;] &gt;&gt;&gt; print &quot;lst1: %r, address is %d&quot; % (lst1, id(lst1)) lst1: [1, 2, 3, &#39;a&#39;], address is 139715299231864 &gt;&gt;&gt; lst1.append(&#39;to be&#39;) &gt;&gt;&gt; print &quot;lst1: %r, address is %d&quot; % (lst1, id(lst1)) lst1: [1, 2, 3, &#39;a&#39;, &#39;to be&#39;], address is 139715299231864 &gt;&gt;&gt; lst1.insert(0,0) &gt;&gt;&gt; print &quot;lst1: %r, address is %d&quot; % (lst1, id(lst1)) lst1: [0, 1, 2, 3, &#39;a&#39;, &#39;to be&#39;], address is 139715299231864 &gt;&gt;&gt; lst1[0] = &#39;to be&#39; &gt;&gt;&gt; print &quot;lst1: %r, address is %d&quot; % (lst1, id(lst1)) lst1: [&#39;to be&#39;, 1, 2, 3, &#39;a&#39;, &#39;to be&#39;], address is 139715299231864 当对列表中的元素进行一些增删改的操作的时候，是不会影响到lst1列表本身的整个列表地址的，只会改变其内部元素的地址引用。可是当我们对于一个列表重新初始化(赋值)的时候，就给lst1这个变量重新赋予了一个地址，覆盖了原本列表的地址，这个时候，lst1列表的内存id就发生了改变。上面这个道理用在所有复杂的数据类型中都是一样的。 这个原理就解释了最初本例中的list3 为什么会等于list1了，因为append对列表元素的操作不会更改内存地址，所以list1 and list3是一致的 2. copy 首先，为什么要copy，从python的赋值原理可以看出， 对于list，dict等复杂数据结构来说，赋值等于完全共享资源。然而有时候需要既要保存原始数据，又要对数据进行新的操作，这时就需要copy了。 python的copy模块，有两种方法，一种是普通的copy，也叫浅拷贝；一种是deepcopy，又叫深拷贝。 浅拷贝，copy 浅copy，无论多么复杂的数据结构， 浅拷贝只copy一层数据结构。 浅拷贝的形式有几种： 切片操作：list_b = list_a[:] 或者 list_b = [each for each in list_a] 工厂函数：list_b = list(list_a) copy函数：list_b = copy.copy(list_a) &gt;&gt;&gt; import copy ## 浅copy，将lst2 copy成copylst &gt;&gt;&gt; lst1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &gt;&gt;&gt; lst2 = [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, lst1] &gt;&gt;&gt; copylst = copy.copy(lst2) &gt;&gt;&gt; print &quot; The source lst is: &quot;, lst2 The source lst is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] &gt;&gt;&gt; print &quot;The copy list is: &quot;, copylst The copy list is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] ##更改lst2内容，copylst不变 &gt;&gt;&gt;lst2.append(&#39;lst2 str5&#39;) &gt;&gt;&gt; print &quot; The source lst is: &quot;, lst2 The source lst is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], &#39;lst2 str5&#39;] &gt;&gt;&gt; print &quot;The copy list is: &quot;, copylst The copy list is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] ##更改lst1内容，copylst和lst2共同变化，更改copylst的话，也会引起lst1变化 &gt;&gt;&gt; lst1[0] = &#39;biubiu&#39; &gt;&gt;&gt; print &quot; The source lst is: &quot;, lst2 The source lst is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;biubiu&#39;, &#39;b&#39;, &#39;c&#39;], &#39;lst2 str5&#39;] &gt;&gt;&gt; print &quot;The copy list is: &quot;, copylst The copy list is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;biubiu&#39;, &#39;b&#39;, &#39;c&#39;]] 也就是说， 在字典套字典、列表套字典、字典套列表，列表套列表，以及各种复杂数据结构的嵌套中，浅拷贝只能copy“最外面的一层”数据，使其指向的地址无变化，但是对于复杂的数据，即使地址不变，里面的内容还可能发生变化(如例子里的lst1)，所以这时候，源数据和copy数据就会共同变化。 深拷贝，deepcopy deepcopy的原理就是完全开辟一块新的内存空间，无论数据结构有几层，都把其地址中指向的内容层层找到，然后复制下来，放在新的地址里，源数据和目标数据的地址完全隔离，所以也就不会再有关联了。 &gt;&gt;&gt; import copy &gt;&gt;&gt; lst1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &gt;&gt;&gt; lst2 = [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, lst1] &gt;&gt;&gt; dcopylst = copy.deepcopy(lst2) &gt;&gt;&gt; print lst2 [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] &gt;&gt;&gt; print dcopylst [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] ## 无论更改lst2还是lst1，都不会对deepcopy的dcopylst有影响 &gt;&gt;&gt; lst2.append(&#39;lst2 biubiubiu&#39;) &gt;&gt;&gt;lst1.append(&#39;lst1 bobobo&#39;) &gt;&gt;&gt; print lst2 [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;lst1 bobobo&#39;], &#39;lst2 biubiubiu&#39;] &gt;&gt;&gt; print dcopylst [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] ##反之亦然 &gt;&gt;&gt; dcopylst[3].append(&#39;lst1 bububu&#39;) &gt;&gt;&gt; print dcopylst [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;lst1 bububu&#39;]] &gt;&gt;&gt; print lst1 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;lst1 bobobo&#39;] &gt;&gt;&gt; print lst2 [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;lst1 bobobo&#39;], &#39;lst2 biubiubiu&#39;]" /> <meta property="og:description" content="本系列列举一些常见的Python知识点，本文涉及变量的赋值，存储和深浅拷贝。 首先上结论： 赋值，浅拷贝，深拷贝中，源数据和目标数据的相关性为 赋值 &lt; 浅copy &lt; 深copy 赋值：a = b，a和b只是名字不同，内容完全共同变化。 copy： 浅拷贝的第一层不共同变化，如果有嵌套list，则嵌套部分共同变化。 deepcopy： 深拷贝所有内容完全独立，无共同变化。 1. 先举例，请解释输出的原理 [root@localhost mystuff]# cat it01.py ## explain follow return value of list and why? def extendList(val, list = []): list.append(val) return list list1 = extendList(10) list2 = extendList(123, []) list3 = extendList(&#39;a&#39;) print &quot;list1 = %s&quot; % list1 print &quot;list2 = %s&quot; % list2 print &quot;list3 = %s&quot; % list3 [root@localhost mystuff]# python it01.py list1 = [10, &#39;a&#39;] list2 = [123] list3 = [10, &#39;a&#39;] 首先解释为什么list3是[10， ‘a’] 而不是 [‘a’]。因为函数extendList的参数默认值：list = []只有在函数被定义的时候（或者第一次调用的时候？）定义一次，如果继续进行函数调用，函数参数的默认值是不进行定义的，因为这时候这个参数已经有了值，无论这个值是否被改变，它都已经固定了，当然这是不给函数传递参数的前提下。 然后解释为什么list1会随着list3的赋值而变化。这里涉及到python变量存储和深浅copy的知识如下： 参考Eva_J的博客 python的变量存储 python中变量的存储采用引用语义的方式，存储的只是一个变量的值所在的内存地址，而不是变量的值本身。 顺便提一下，C语言不是这种方式，是值语义，即变量存储的就是一个值本身。 所以，python变量的大小都是一样的，因为内存地址的大小一致。而C语言的变量大小是不固定的。 python中一切皆对象，即使不同的变量类型， 本质上也都是存储地址，如下图： 数据初始化对内存地址的影响 变量每一次初始化， 都开辟了一个新空间，然后将新内容的新地址赋给变量： &gt;&gt;&gt; st1 = &quot;Hello World.&quot; &gt;&gt;&gt; print id(st1) 139715299268008 &gt;&gt;&gt; st1 = &quot;to be&quot; &gt;&gt;&gt; print id(st1) 139715299265296 等等，不同内容的地址肯定是不一致的，但是相同内容的地址就一定一致么？答案是no： &gt;&gt;&gt; st1 = &quot;Hello World.&quot; &gt;&gt;&gt; print id(st1) 139715299268008 &gt;&gt;&gt; st2 = &quot;Hello World.&quot; &gt;&gt;&gt; print id(st2) 139715299268064 再等等，那相同内容的地址，肯定也不一致么，那岂不是浪费很多内存空间？答案还是no： &gt;&gt;&gt; st1 = 123 &gt;&gt;&gt; st2 = 123 &gt;&gt;&gt; print id(st1), id(st2) 34236496 34236496 &gt;&gt;&gt; st1 = 123456123 &gt;&gt;&gt; st2 = 123456123 &gt;&gt;&gt; print id(st1), id(st2) 34569208 34569016 找不到规律，目前唯一能确定的是：不同内容的内存地址是不一样的,而且，对简单数据结构(string)的重新初始化，会使内存地址变动 &gt;&gt;&gt; st1 = 123 &gt;&gt;&gt; st2 = st1 &gt;&gt;&gt; print id(st1), id(st2) 34236496 34236496 &gt;&gt;&gt; st1 = 456 &gt;&gt;&gt; print &quot;st1: %d, st1 address: %d&quot; % (st1, id(st1)) st1: 456, st1 address: 34569208 &gt;&gt;&gt; print &quot;st2: %d, st2 address: %d&quot; % (st2, id(st2)) st2: 123, st2 address: 34236496 数据结构内部元素的变化对内存地址的影响 &gt;&gt;&gt; lst1 = [1, 2, 3, &#39;a&#39;] &gt;&gt;&gt; print &quot;lst1: %r, address is %d&quot; % (lst1, id(lst1)) lst1: [1, 2, 3, &#39;a&#39;], address is 139715299231864 &gt;&gt;&gt; lst1.append(&#39;to be&#39;) &gt;&gt;&gt; print &quot;lst1: %r, address is %d&quot; % (lst1, id(lst1)) lst1: [1, 2, 3, &#39;a&#39;, &#39;to be&#39;], address is 139715299231864 &gt;&gt;&gt; lst1.insert(0,0) &gt;&gt;&gt; print &quot;lst1: %r, address is %d&quot; % (lst1, id(lst1)) lst1: [0, 1, 2, 3, &#39;a&#39;, &#39;to be&#39;], address is 139715299231864 &gt;&gt;&gt; lst1[0] = &#39;to be&#39; &gt;&gt;&gt; print &quot;lst1: %r, address is %d&quot; % (lst1, id(lst1)) lst1: [&#39;to be&#39;, 1, 2, 3, &#39;a&#39;, &#39;to be&#39;], address is 139715299231864 当对列表中的元素进行一些增删改的操作的时候，是不会影响到lst1列表本身的整个列表地址的，只会改变其内部元素的地址引用。可是当我们对于一个列表重新初始化(赋值)的时候，就给lst1这个变量重新赋予了一个地址，覆盖了原本列表的地址，这个时候，lst1列表的内存id就发生了改变。上面这个道理用在所有复杂的数据类型中都是一样的。 这个原理就解释了最初本例中的list3 为什么会等于list1了，因为append对列表元素的操作不会更改内存地址，所以list1 and list3是一致的 2. copy 首先，为什么要copy，从python的赋值原理可以看出， 对于list，dict等复杂数据结构来说，赋值等于完全共享资源。然而有时候需要既要保存原始数据，又要对数据进行新的操作，这时就需要copy了。 python的copy模块，有两种方法，一种是普通的copy，也叫浅拷贝；一种是deepcopy，又叫深拷贝。 浅拷贝，copy 浅copy，无论多么复杂的数据结构， 浅拷贝只copy一层数据结构。 浅拷贝的形式有几种： 切片操作：list_b = list_a[:] 或者 list_b = [each for each in list_a] 工厂函数：list_b = list(list_a) copy函数：list_b = copy.copy(list_a) &gt;&gt;&gt; import copy ## 浅copy，将lst2 copy成copylst &gt;&gt;&gt; lst1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &gt;&gt;&gt; lst2 = [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, lst1] &gt;&gt;&gt; copylst = copy.copy(lst2) &gt;&gt;&gt; print &quot; The source lst is: &quot;, lst2 The source lst is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] &gt;&gt;&gt; print &quot;The copy list is: &quot;, copylst The copy list is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] ##更改lst2内容，copylst不变 &gt;&gt;&gt;lst2.append(&#39;lst2 str5&#39;) &gt;&gt;&gt; print &quot; The source lst is: &quot;, lst2 The source lst is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], &#39;lst2 str5&#39;] &gt;&gt;&gt; print &quot;The copy list is: &quot;, copylst The copy list is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] ##更改lst1内容，copylst和lst2共同变化，更改copylst的话，也会引起lst1变化 &gt;&gt;&gt; lst1[0] = &#39;biubiu&#39; &gt;&gt;&gt; print &quot; The source lst is: &quot;, lst2 The source lst is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;biubiu&#39;, &#39;b&#39;, &#39;c&#39;], &#39;lst2 str5&#39;] &gt;&gt;&gt; print &quot;The copy list is: &quot;, copylst The copy list is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;biubiu&#39;, &#39;b&#39;, &#39;c&#39;]] 也就是说， 在字典套字典、列表套字典、字典套列表，列表套列表，以及各种复杂数据结构的嵌套中，浅拷贝只能copy“最外面的一层”数据，使其指向的地址无变化，但是对于复杂的数据，即使地址不变，里面的内容还可能发生变化(如例子里的lst1)，所以这时候，源数据和copy数据就会共同变化。 深拷贝，deepcopy deepcopy的原理就是完全开辟一块新的内存空间，无论数据结构有几层，都把其地址中指向的内容层层找到，然后复制下来，放在新的地址里，源数据和目标数据的地址完全隔离，所以也就不会再有关联了。 &gt;&gt;&gt; import copy &gt;&gt;&gt; lst1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &gt;&gt;&gt; lst2 = [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, lst1] &gt;&gt;&gt; dcopylst = copy.deepcopy(lst2) &gt;&gt;&gt; print lst2 [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] &gt;&gt;&gt; print dcopylst [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] ## 无论更改lst2还是lst1，都不会对deepcopy的dcopylst有影响 &gt;&gt;&gt; lst2.append(&#39;lst2 biubiubiu&#39;) &gt;&gt;&gt;lst1.append(&#39;lst1 bobobo&#39;) &gt;&gt;&gt; print lst2 [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;lst1 bobobo&#39;], &#39;lst2 biubiubiu&#39;] &gt;&gt;&gt; print dcopylst [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] ##反之亦然 &gt;&gt;&gt; dcopylst[3].append(&#39;lst1 bububu&#39;) &gt;&gt;&gt; print dcopylst [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;lst1 bububu&#39;]] &gt;&gt;&gt; print lst1 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;lst1 bobobo&#39;] &gt;&gt;&gt; print lst2 [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;lst1 bobobo&#39;], &#39;lst2 biubiubiu&#39;]" /> <link rel="canonical" href="http://localhost:4000/2017/04/20/Python-practice-value-and-copy.html" /> <meta property="og:url" content="http://localhost:4000/2017/04/20/Python-practice-value-and-copy.html" /> <meta property="og:site_name" content="doing blog" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2017-04-20T00:00:00-04:00" /> <meta name="twitter:card" content="summary" /> <meta name="twitter:site" content="@" /> <meta name="twitter:creator" content="@doing" /> <script type="application/ld+json"> {"@context":"http://schema.org","@type":"BlogPosting","headline":"Python知识点 – 变量赋值与深浅copy","author":{"@type":"Person","name":"doing"},"datePublished":"2017-04-20T00:00:00-04:00","dateModified":"2017-04-20T00:00:00-04:00","description":"本系列列举一些常见的Python知识点，本文涉及变量的赋值，存储和深浅拷贝。 首先上结论： 赋值，浅拷贝，深拷贝中，源数据和目标数据的相关性为 赋值 &lt; 浅copy &lt; 深copy 赋值：a = b，a和b只是名字不同，内容完全共同变化。 copy： 浅拷贝的第一层不共同变化，如果有嵌套list，则嵌套部分共同变化。 deepcopy： 深拷贝所有内容完全独立，无共同变化。 1. 先举例，请解释输出的原理 [root@localhost mystuff]# cat it01.py ## explain follow return value of list and why? def extendList(val, list = []): list.append(val) return list list1 = extendList(10) list2 = extendList(123, []) list3 = extendList(&#39;a&#39;) print &quot;list1 = %s&quot; % list1 print &quot;list2 = %s&quot; % list2 print &quot;list3 = %s&quot; % list3 [root@localhost mystuff]# python it01.py list1 = [10, &#39;a&#39;] list2 = [123] list3 = [10, &#39;a&#39;] 首先解释为什么list3是[10， ‘a’] 而不是 [‘a’]。因为函数extendList的参数默认值：list = []只有在函数被定义的时候（或者第一次调用的时候？）定义一次，如果继续进行函数调用，函数参数的默认值是不进行定义的，因为这时候这个参数已经有了值，无论这个值是否被改变，它都已经固定了，当然这是不给函数传递参数的前提下。 然后解释为什么list1会随着list3的赋值而变化。这里涉及到python变量存储和深浅copy的知识如下： 参考Eva_J的博客 python的变量存储 python中变量的存储采用引用语义的方式，存储的只是一个变量的值所在的内存地址，而不是变量的值本身。 顺便提一下，C语言不是这种方式，是值语义，即变量存储的就是一个值本身。 所以，python变量的大小都是一样的，因为内存地址的大小一致。而C语言的变量大小是不固定的。 python中一切皆对象，即使不同的变量类型， 本质上也都是存储地址，如下图： 数据初始化对内存地址的影响 变量每一次初始化， 都开辟了一个新空间，然后将新内容的新地址赋给变量： &gt;&gt;&gt; st1 = &quot;Hello World.&quot; &gt;&gt;&gt; print id(st1) 139715299268008 &gt;&gt;&gt; st1 = &quot;to be&quot; &gt;&gt;&gt; print id(st1) 139715299265296 等等，不同内容的地址肯定是不一致的，但是相同内容的地址就一定一致么？答案是no： &gt;&gt;&gt; st1 = &quot;Hello World.&quot; &gt;&gt;&gt; print id(st1) 139715299268008 &gt;&gt;&gt; st2 = &quot;Hello World.&quot; &gt;&gt;&gt; print id(st2) 139715299268064 再等等，那相同内容的地址，肯定也不一致么，那岂不是浪费很多内存空间？答案还是no： &gt;&gt;&gt; st1 = 123 &gt;&gt;&gt; st2 = 123 &gt;&gt;&gt; print id(st1), id(st2) 34236496 34236496 &gt;&gt;&gt; st1 = 123456123 &gt;&gt;&gt; st2 = 123456123 &gt;&gt;&gt; print id(st1), id(st2) 34569208 34569016 找不到规律，目前唯一能确定的是：不同内容的内存地址是不一样的,而且，对简单数据结构(string)的重新初始化，会使内存地址变动 &gt;&gt;&gt; st1 = 123 &gt;&gt;&gt; st2 = st1 &gt;&gt;&gt; print id(st1), id(st2) 34236496 34236496 &gt;&gt;&gt; st1 = 456 &gt;&gt;&gt; print &quot;st1: %d, st1 address: %d&quot; % (st1, id(st1)) st1: 456, st1 address: 34569208 &gt;&gt;&gt; print &quot;st2: %d, st2 address: %d&quot; % (st2, id(st2)) st2: 123, st2 address: 34236496 数据结构内部元素的变化对内存地址的影响 &gt;&gt;&gt; lst1 = [1, 2, 3, &#39;a&#39;] &gt;&gt;&gt; print &quot;lst1: %r, address is %d&quot; % (lst1, id(lst1)) lst1: [1, 2, 3, &#39;a&#39;], address is 139715299231864 &gt;&gt;&gt; lst1.append(&#39;to be&#39;) &gt;&gt;&gt; print &quot;lst1: %r, address is %d&quot; % (lst1, id(lst1)) lst1: [1, 2, 3, &#39;a&#39;, &#39;to be&#39;], address is 139715299231864 &gt;&gt;&gt; lst1.insert(0,0) &gt;&gt;&gt; print &quot;lst1: %r, address is %d&quot; % (lst1, id(lst1)) lst1: [0, 1, 2, 3, &#39;a&#39;, &#39;to be&#39;], address is 139715299231864 &gt;&gt;&gt; lst1[0] = &#39;to be&#39; &gt;&gt;&gt; print &quot;lst1: %r, address is %d&quot; % (lst1, id(lst1)) lst1: [&#39;to be&#39;, 1, 2, 3, &#39;a&#39;, &#39;to be&#39;], address is 139715299231864 当对列表中的元素进行一些增删改的操作的时候，是不会影响到lst1列表本身的整个列表地址的，只会改变其内部元素的地址引用。可是当我们对于一个列表重新初始化(赋值)的时候，就给lst1这个变量重新赋予了一个地址，覆盖了原本列表的地址，这个时候，lst1列表的内存id就发生了改变。上面这个道理用在所有复杂的数据类型中都是一样的。 这个原理就解释了最初本例中的list3 为什么会等于list1了，因为append对列表元素的操作不会更改内存地址，所以list1 and list3是一致的 2. copy 首先，为什么要copy，从python的赋值原理可以看出， 对于list，dict等复杂数据结构来说，赋值等于完全共享资源。然而有时候需要既要保存原始数据，又要对数据进行新的操作，这时就需要copy了。 python的copy模块，有两种方法，一种是普通的copy，也叫浅拷贝；一种是deepcopy，又叫深拷贝。 浅拷贝，copy 浅copy，无论多么复杂的数据结构， 浅拷贝只copy一层数据结构。 浅拷贝的形式有几种： 切片操作：list_b = list_a[:] 或者 list_b = [each for each in list_a] 工厂函数：list_b = list(list_a) copy函数：list_b = copy.copy(list_a) &gt;&gt;&gt; import copy ## 浅copy，将lst2 copy成copylst &gt;&gt;&gt; lst1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &gt;&gt;&gt; lst2 = [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, lst1] &gt;&gt;&gt; copylst = copy.copy(lst2) &gt;&gt;&gt; print &quot; The source lst is: &quot;, lst2 The source lst is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] &gt;&gt;&gt; print &quot;The copy list is: &quot;, copylst The copy list is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] ##更改lst2内容，copylst不变 &gt;&gt;&gt;lst2.append(&#39;lst2 str5&#39;) &gt;&gt;&gt; print &quot; The source lst is: &quot;, lst2 The source lst is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], &#39;lst2 str5&#39;] &gt;&gt;&gt; print &quot;The copy list is: &quot;, copylst The copy list is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] ##更改lst1内容，copylst和lst2共同变化，更改copylst的话，也会引起lst1变化 &gt;&gt;&gt; lst1[0] = &#39;biubiu&#39; &gt;&gt;&gt; print &quot; The source lst is: &quot;, lst2 The source lst is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;biubiu&#39;, &#39;b&#39;, &#39;c&#39;], &#39;lst2 str5&#39;] &gt;&gt;&gt; print &quot;The copy list is: &quot;, copylst The copy list is: [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;biubiu&#39;, &#39;b&#39;, &#39;c&#39;]] 也就是说， 在字典套字典、列表套字典、字典套列表，列表套列表，以及各种复杂数据结构的嵌套中，浅拷贝只能copy“最外面的一层”数据，使其指向的地址无变化，但是对于复杂的数据，即使地址不变，里面的内容还可能发生变化(如例子里的lst1)，所以这时候，源数据和copy数据就会共同变化。 深拷贝，deepcopy deepcopy的原理就是完全开辟一块新的内存空间，无论数据结构有几层，都把其地址中指向的内容层层找到，然后复制下来，放在新的地址里，源数据和目标数据的地址完全隔离，所以也就不会再有关联了。 &gt;&gt;&gt; import copy &gt;&gt;&gt; lst1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &gt;&gt;&gt; lst2 = [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, lst1] &gt;&gt;&gt; dcopylst = copy.deepcopy(lst2) &gt;&gt;&gt; print lst2 [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] &gt;&gt;&gt; print dcopylst [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] ## 无论更改lst2还是lst1，都不会对deepcopy的dcopylst有影响 &gt;&gt;&gt; lst2.append(&#39;lst2 biubiubiu&#39;) &gt;&gt;&gt;lst1.append(&#39;lst1 bobobo&#39;) &gt;&gt;&gt; print lst2 [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;lst1 bobobo&#39;], &#39;lst2 biubiubiu&#39;] &gt;&gt;&gt; print dcopylst [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] ##反之亦然 &gt;&gt;&gt; dcopylst[3].append(&#39;lst1 bububu&#39;) &gt;&gt;&gt; print dcopylst [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;lst1 bububu&#39;]] &gt;&gt;&gt; print lst1 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;lst1 bobobo&#39;] &gt;&gt;&gt; print lst2 [&#39;str1&#39;, &#39;str2&#39;, &#39;str3&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;lst1 bobobo&#39;], &#39;lst2 biubiubiu&#39;]","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2017/04/20/Python-practice-value-and-copy.html"},"url":"http://localhost:4000/2017/04/20/Python-practice-value-and-copy.html"}</script> <!-- End Jekyll SEO tag --> <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="doing blog" /> <script src="/assets/js/prefixfree.js"></script> </head> <body> <aside id="sidebar" class="open"> <div id="sidebar-left"> <a id="sidebar-avatar" href="/"> <img id="sidebar-avatar-img" alt="" src="https://raw.githubusercontent.com/doingdd/img/master/d.png"/> </a> <div id="sidebar-social"> <a href="/pages/feed.xml" class="sidebar-social-icon feed"></a> <a href="mailto:doingduxuan@163.com" class="sidebar-social-icon email"></a> <!-- Generate icon by yourself https://icomoon.io/app/#/select --> <a href="https://twitter.com/masonsuyan" class="sidebar-social-icon twitter" target="_blank"></a> <a href="http://www.weibo.com/doingdd" class="sidebar-social-icon weibo" target="_blank"></a> <a href="https://github.com/doingdd" class="sidebar-social-icon github" target="_blank"></a> <a href="https://www.linkedin.com/in/doingdd" class="sidebar-social-icon linkedin" target="_blank"></a> <a href="https://www.instagram.com/doingdd" class="sidebar-social-icon instagram" target="_blank"></a> </div> <ul id="sidebar-tags"> <li class="sidebar-tag active" data-filter="recent">最新文章</li> <li class="sidebar-tag" data-filter="技术">技术</li> <li class="sidebar-tag" data-filter="工具">工具</li> <li class="sidebar-tag" data-filter="Linux">Linux</li> <li class="sidebar-tag" data-filter="Python">Python</li> <li class="sidebar-tag" data-filter="life">life</li> </ul> </div> <div id="sidebar-right"> <div id="search-box"> <input id="search-input" type="text" placeholder="Search" /> </div> <nav id="toc"> <a class="toc-link" data-tags="Linux" href="/2017/05/24/Linux-Shell-String.html"> Linux shell内置字符串操作 </a> <a class="toc-link" data-tags="Python" href="/2017/05/21/Python-library-argparse.html"> Python标准库 -- argparse </a> <a class="toc-link" data-tags="Python" href="/2017/05/20/Python-Q&A-2.html"> Python问答系列2 </a> <a class="toc-link" data-tags="Python" href="/2017/05/19/Python-Q&A-1.html"> Pyhon问答系列1 </a> <a class="toc-link" data-tags="Python" href="/2017/05/13/Python-library-json.html"> Python标准库 -- json </a> <a class="toc-link" data-tags="Python" href="/2017/05/05/Python-library-logging.html"> Python标准库 -- logging </a> <a class="toc-link" data-tags="Linux" href="/2017/05/04/Gnome-installation-on-CentOS.html"> centos 安装gnome和vnc </a> <a class="toc-link" data-tags="Python" href="/2017/05/03/Python-standard-library-tempfile.html"> Python标准库 -- tempfile </a> <a class="toc-link" data-tags="life" href="/2017/05/02/test-forms.html"> test forms </a> <a class="toc-link" data-tags="Python" href="/2017/05/01/Python-Iterator-Generator.html"> Python知识点 -- 迭代器和生成器 </a> <a class="toc-link" data-tags="Python" href="/2017/04/28/Python-lambda.html"> Python知识点 -- lambda表达式 </a> <a class="toc-link" data-tags="Linux" href="/2017/04/28/Linux-shell.html"> Linux中shell的理解和不同shell的区别 </a> <a class="toc-link" data-tags="Python" href="/2017/04/27/Python-practice-generator.html"> Python知识点 -- 装饰器 </a> <a class="toc-link" data-tags="Linux" href="/2017/04/25/linux-value.html"> Linux 环境变量 </a> <a class="toc-link" data-tags="Python" href="/2017/04/20/Python-practice-value-and-copy.html"> Python知识点 -- 变量赋值与深浅copy </a> <a class="toc-link" data-tags="Python" href="/2017/04/19/Difference-between-python2-and-python3.html"> Python2和Python3的区别 </a> <a class="toc-link" data-tags="Linux" href="/2017/04/19/Linux-content-tree.html"> Linux 目录结构 </a> <a class="toc-link" data-tags="Python" href="/2017/04/14/Python-file-process.html"> Python IO 文件处理 </a> <a class="toc-link" data-tags="Python" href="/2017/04/13/Python-list-usage.html"> Python list usage </a> <a class="toc-link" data-tags="Linux" href="/2017/03/29/basic-linux-usage.html"> Linux 基础命令 </a> <a class="toc-link" data-tags="工具" href="/2017/02/21/docker-summary.html"> Docker 使用总结 </a> <a class="toc-link" data-tags="工具" href="/2016/12/31/deploy-shadowsocks-on-ubuntu.html"> 在 Ubuntu 下部署 Shadowsocks </a> <a class="toc-link" data-tags="工具" href="/2016/12/30/deploy-l2tp-on-ubuntu.html"> 在 Ubuntu 下部署 L2TP VPN </a> <a class="toc-link" data-tags="工具" href="/2016/11/09/my-writing-tools.html"> 我使用的收藏，写作和分享工具 </a> <a class="toc-link" data-tags="技术" href="/2015/09/07/sort-algorithms.html"> 七种常见经典排序算法总结（C++实现） </a> <a class="toc-link" data-tags="工具" href="/2015/01/10/use-dropzone-and-qiniu-to-store-blog-images.html"> 使用Dropzone和七牛优化博客图床 </a> <a class="toc-link" data-tags="技术" href="/2014/04/16/insert-large-number-of-data-in-mysql.html"> MySQL大量数据插入方法性能分析比较 </a> <a class="toc-link" data-tags="工具" href="/2014/04/10/install-vagrant-in-mac.html"> 在Mac下安装使用Vagrant </a> <a class="toc-link" data-tags="工具" href="/2014/03/20/php-debug-with-xdebug.html"> 用Xdebug和Sublime调试PHP代码 </a> <a class="toc-link" data-tags="工具" href="/2014/02/12/how-to-deploy-a-blog-on-github-by-jekyll.html"> 在Github上搭建Jekyll博客和创建主题 </a> <a class="toc-link" data-tags="技术" href="/2014/01/30/understanding-the-github-workflow.html"> 了解GitHub工作流【译】 </a> <a class="toc-link" data-tags="技术" href="/2014/01/17/python-script-of-sae-log-download.html"> Python脚本--下载合并SAE日志 </a> <a class="toc-link" data-tags="工具" href="/2013/12/11/lamp-in-mac.html"> Mac下用brew搭建LNMP和LAMP开发环境 </a> <a class="toc-link" data-tags="工具" href="/2013/12/11/deploy-pptp-vpn-in-ubuntu.html"> 在ubuntu下搭建pptp vpn服务器 </a> <a class="toc-link" data-tags="工具" href="/2013/12/08/linux-command-continue.html"> Linux下多个命令连续执行方法 </a> <a class="toc-link" data-tags="技术" href="/2013/10/01/deploy-ceilometer-of-openstack.html"> 部署Ceilometer到已有环境中 </a> <a class="toc-link" data-tags="工具" href="/2013/08/28/change-bootstrap-to-3.html"> 更新前端框架到Bootstrap3 </a> <a class="toc-link" data-tags="工具" href="/2013/08/06/tools-of-reading.html"> 我与工具--阅读和知识管理 </a> <a class="toc-link" data-tags="工具" href="/2013/08/04/something-about-tools-i-used.html"> 我与工具 </a> <a class="toc-link" data-tags="技术" href="/2013/06/12/hacking-in-openstack-ceilometer-collector.html"> OpenStack Ceilometer Collector代码解读 </a> <a class="toc-link" data-tags="技术" href="/2013/06/12/hacking-in-openstack-ceilometer-api.html"> OpenStack Ceilometer数据与API源码详解 </a> <a class="toc-link" data-tags="技术" href="/2013/06/11/pipeline-of-openstack-ceilometer.html"> OpenStack Ceilometer Pipeline代码解读 </a> <a class="toc-link" data-tags="技术" href="/2013/06/11/hacking-in-openstack-ceilometer-compute-agent.html"> OpenStack Ceilometer Agent源码解读 </a> <a class="toc-link" data-tags="技术" href="/2013/06/09/learn-python-stevedore-module-in-detail.html"> 学习Python动态扩展包stevedore </a> <a class="toc-link" data-tags="技术" href="/2013/06/09/learn-python-abc-module.html"> 学习Python的ABC模块 </a> <a class="toc-link" data-tags="技术" href="/2013/06/07/learn-python-setuptools-in-detail.html"> Python包管理工具setuptools详解 </a> <a class="toc-link" data-tags="技术" href="/2013/05/27/openstack-horizon-locale.html"> OpenStack Horizon 中文本地化 </a> <a class="toc-link" data-tags="工具" href="/2013/05/23/install-mysql-and-mongo-web-admin.html"> 安装MySQL和MongoDB的WEB管理界面 </a> <a class="toc-link" data-tags="工具" href="/2013/05/22/change-to-zsh.html"> 从Bash切换到Zsh </a> <a class="toc-link" data-tags="工具" href="/2013/05/20/set-proxy-for-git-or-apt.html"> 给Git或者APT设置goagent代理 </a> <a class="toc-link" data-tags="技术" href="/2013/05/19/what-is-wsgi.html"> WSGI学习 </a> <a class="toc-link" data-tags="技术" href="/2013/05/16/deploy-openstack-grizzly-in-virtual-machine.html"> 在虚拟机单机部署OpenStack Grizzly </a> <a class="toc-link" data-tags="技术" href="/2013/05/15/learn-how-to-use-distutils.html"> 学习使用python打包工具distutils </a> <a class="toc-link" data-tags="技术" href="/2013/05/15/different-between-python-package-tools.html"> python包工具之间的关系 </a> <a class="toc-link" data-tags="技术" href="/2013/05/15/create-ubuntu-image-for-openstack.html"> 给OpenStack创建Ubuntu镜像 </a> <a class="toc-link" data-tags="技术" href="/2013/05/13/openstack-grizzly-multihost-deployment-doc.html"> OpenStack Grizzly Multihost部署文档 </a> <a class="toc-link" data-tags="技术" href="/2013/05/06/why-use-pip-over-easy-install.html"> 为什么使用pip而不是easy_install </a> <a class="toc-link" data-tags="技术" href="/2013/05/06/interactive-coding-ipython.html"> 交互式编程-IPython </a> <a class="toc-link" data-tags="技术" href="/2013/05/03/create-windows-7-image-for-openstack.html"> 给OpenStack创建Win7镜像 </a> <a class="toc-link" data-tags="技术" href="/2013/05/01/terminal-command-of-ceilometer.html"> Ceilometer的命令行使用 </a> <a class="toc-link" data-tags="技术" href="/2013/05/01/deploy-a-ceilometer-horizon-project.html"> 部署一个ceilometer-horizon项目 </a> <a class="toc-link" data-tags="技术" href="/2013/04/26/create-windows-xp-image-for-openstack.html"> 给OpenStack创建Windows XP镜像 </a> <a class="toc-link" data-tags="工具" href="/2013/04/22/wordpress-to-jekyll.html"> 博客迁移完成 </a> <a class="toc-link" data-tags="工具" href="/2013/04/22/ignore-password-in-git-push.html"> 让git push命令不再需要密码 </a> <a class="toc-link" data-tags="工具" href="/2013/04/22/highlight-of-jekyll.html"> Jekyll的中的代码高亮 </a> <a class="toc-link" data-tags="工具" href="/2013/04/22/add-svn-ignore-file.html"> 给SVN控制的项目添加忽略文件/文件夹 </a> <a class="toc-link" data-tags="工具" href="/2013/04/21/add-snippet.html"> 给sublime增加snippet </a> <a class="toc-link" data-tags="技术" href="/2013/03/27/glossary-of-ceilometer.html"> OpenStack Ceilometer的一些术语 </a> <a class="toc-link" data-tags="工具" href="/2013/03/25/tools-of-sever-deployment.html"> 服务器自动化部署及运维常见工具 </a> <a class="toc-link" data-tags="工具" href="/2013/03/25/open-tcp-port-of-libvirt.html"> Linux下开启Libvirtd的tcp监控 </a> <a class="toc-link" data-tags="技术" href="/2013/03/21/vnc-vs-rdp.html"> VNC和远程桌面的区别 </a> <a class="toc-link" data-tags="技术" href="/2013/03/21/introduction-of-ceilometer.html"> OpenStack Ceilometer项目简介 </a> <a class="toc-link" data-tags="技术" href="/2013/03/20/different-bewteen-kvm-xen-qemu.html"> 虚拟化中KVM, Xen, Qemu的区别 </a> <a class="toc-link" data-tags="技术" href="/2013/03/20/debug-and-modify-openstack-horizon.html"> 调试和修改OpenStack中的Horizon部分 </a> <a class="toc-link" data-tags="工具" href="/2013/02/25/quick-open-in-windows.html"> win7快速打开应用程序或文件 </a> <a class="toc-link" data-tags="工具" href="/2013/01/16/create-remote-resp.html"> git创建远程库 </a> <a class="toc-link" data-tags="工具" href="/2013/01/09/remote-access-of-mysql.html"> MySQL远程访问 </a> <a class="toc-link" data-tags="工具" href="/2012/12/30/share-windows-and-linux.html"> Windows和Linux切换最终解决方案 </a> <a class="toc-link" data-tags="技术" href="/2012/11/08/openstack-nova-internal.html"> OpenStack Nova内部机制【译】 </a> </nav> </div> </aside> <main id="main" class="open"> <article class="post container"> <div class="post-meta"> <span class="post-meta-span date">2017 April 20</span> </div> <h1 class="post-title">Python知识点 -- 变量赋值与深浅copy</h1> <h4 id="本系列列举一些常见的python知识点本文涉及变量的赋值存储和深浅拷贝">本系列列举一些常见的Python知识点，本文涉及变量的赋值，存储和深浅拷贝。</h4> <p>首先上结论： 赋值，浅拷贝，深拷贝中，源数据和目标数据的相关性为</p> <p><strong>赋值 &lt; 浅copy &lt; 深copy</strong></p> <p>赋值：a = b，a和b只是名字不同，内容完全共同变化。 <br /> copy： 浅拷贝的第一层不共同变化，如果有嵌套list，则嵌套部分共同变化。<br /> deepcopy： 深拷贝所有内容完全独立，无共同变化。</p> <h3 id="1-先举例请解释输出的原理">1. 先举例，请解释输出的原理</h3> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="p">[</span><span class="n">root</span><span class="nd">@localhost</span> <span class="n">mystuff</span><span class="p">]</span><span class="c"># cat it01.py </span>
<span class="c">## explain follow return value of list and why?</span>

<span class="k">def</span> <span class="nf">extendList</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]):</span>
	<span class="nb">list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">list</span>

<span class="n">list1</span> <span class="o">=</span> <span class="n">extendList</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">list2</span> <span class="o">=</span> <span class="n">extendList</span><span class="p">(</span><span class="mi">123</span><span class="p">,</span> <span class="p">[])</span>
<span class="n">list3</span> <span class="o">=</span> <span class="n">extendList</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>

<span class="k">print</span> <span class="s">"list1 = </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="n">list1</span>
<span class="k">print</span> <span class="s">"list2 = </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="n">list2</span>
<span class="k">print</span> <span class="s">"list3 = </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="n">list3</span>


<span class="p">[</span><span class="n">root</span><span class="nd">@localhost</span> <span class="n">mystuff</span><span class="p">]</span><span class="c"># python it01.py </span>
<span class="n">list1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="s">'a'</span><span class="p">]</span>
<span class="n">list2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">123</span><span class="p">]</span>
<span class="n">list3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="s">'a'</span><span class="p">]</span>
</code></pre></div> <p><strong>首先</strong>解释为什么list3是[10， ‘a’] 而不是 [‘a’]。因为函数extendList的参数默认值：list = []只有在函数被定义的时候（或者第一次调用的时候？）定义一次，如果继续进行函数调用，函数参数的默认值是不进行定义的，因为这时候这个参数已经有了值，无论这个值是否被改变，它都已经固定了，当然这是不给函数传递参数的前提下。<br /> <strong>然后</strong>解释为什么list1会随着list3的赋值而变化。这里涉及到python变量存储和深浅copy的知识如下：<br /> 参考<a href="http://www.cnblogs.com/Eva-J/p/5534037.html">Eva_J的博客</a></p> <h4 id="python的变量存储">python的变量存储</h4> <p>python中变量的存储采用引用语义的方式，存储的只是一个变量的值所在的<strong>内存地址</strong>，而不是变量的值本身。 顺便提一下，C语言不是这种方式，是值语义，即变量存储的就是一个值本身。 所以，python变量的大小都是一样的，因为<strong>内存地址</strong>的大小一致。而C语言的变量大小是不固定的。<br /> python中一切皆对象，即使不同的变量类型， 本质上也都是存储地址，如下图：<br /> <img src="http://oon3ys1qt.bkt.clouddn.com/python_value_storage.png" alt="" /></p> <h4 id="数据初始化对内存地址的影响">数据初始化对内存地址的影响</h4> <p>变量每一次初始化， 都开辟了一个新空间，然后将新内容的新地址赋给变量：</p> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">st1</span> <span class="o">=</span> <span class="s">"Hello World."</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="nb">id</span><span class="p">(</span><span class="n">st1</span><span class="p">)</span>
<span class="mi">139715299268008</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">st1</span> <span class="o">=</span> <span class="s">"to be"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="nb">id</span><span class="p">(</span><span class="n">st1</span><span class="p">)</span>
<span class="mi">139715299265296</span>
</code></pre></div> <p>等等，不同内容的地址肯定是不一致的，但是相同内容的地址就一定一致么？答案是no：</p> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">st1</span> <span class="o">=</span> <span class="s">"Hello World."</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="nb">id</span><span class="p">(</span><span class="n">st1</span><span class="p">)</span>
<span class="mi">139715299268008</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">st2</span> <span class="o">=</span> <span class="s">"Hello World."</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="nb">id</span><span class="p">(</span><span class="n">st2</span><span class="p">)</span>
<span class="mi">139715299268064</span>
</code></pre></div> <p>再等等，那相同内容的地址，肯定也不一致么，那岂不是浪费很多内存空间？答案还是no：</p> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">st1</span> <span class="o">=</span> <span class="mi">123</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">st2</span> <span class="o">=</span> <span class="mi">123</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="nb">id</span><span class="p">(</span><span class="n">st1</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">st2</span><span class="p">)</span>
<span class="mi">34236496</span> <span class="mi">34236496</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">st1</span> <span class="o">=</span> <span class="mi">123456123</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">st2</span> <span class="o">=</span> <span class="mi">123456123</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="nb">id</span><span class="p">(</span><span class="n">st1</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">st2</span><span class="p">)</span>
<span class="mi">34569208</span> <span class="mi">34569016</span>
</code></pre></div> <p>找不到规律，<strong>目前唯一能确定的是：不同内容的内存地址是不一样的,而且，对简单数据结构(string)的重新初始化，会使内存地址变动</strong></p> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">st1</span> <span class="o">=</span> <span class="mi">123</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">st2</span> <span class="o">=</span> <span class="n">st1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="nb">id</span><span class="p">(</span><span class="n">st1</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">st2</span><span class="p">)</span>
<span class="mi">34236496</span> <span class="mi">34236496</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">st1</span> <span class="o">=</span> <span class="mi">456</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s">"st1: </span><span class="si">%</span><span class="s">d, st1 address: </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">st1</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">st1</span><span class="p">))</span> 
<span class="n">st1</span><span class="p">:</span> <span class="mi">456</span><span class="p">,</span> <span class="n">st1</span> <span class="n">address</span><span class="p">:</span> <span class="mi">34569208</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s">"st2: </span><span class="si">%</span><span class="s">d, st2 address: </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">st2</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">st2</span><span class="p">))</span> 
<span class="n">st2</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="n">st2</span> <span class="n">address</span><span class="p">:</span> <span class="mi">34236496</span>

</code></pre></div> <h4 id="数据结构内部元素的变化对内存地址的影响">数据结构内部元素的变化对内存地址的影响</h4> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">lst1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'a'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s">"lst1: </span><span class="si">%</span><span class="s">r, address is </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">lst1</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">lst1</span><span class="p">))</span>
<span class="n">lst1</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'a'</span><span class="p">],</span> <span class="n">address</span> <span class="ow">is</span> <span class="mi">139715299231864</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lst1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'to be'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s">"lst1: </span><span class="si">%</span><span class="s">r, address is </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">lst1</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">lst1</span><span class="p">))</span>
<span class="n">lst1</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'a'</span><span class="p">,</span> <span class="s">'to be'</span><span class="p">],</span> <span class="n">address</span> <span class="ow">is</span> <span class="mi">139715299231864</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lst1</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s">"lst1: </span><span class="si">%</span><span class="s">r, address is </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">lst1</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">lst1</span><span class="p">))</span>
<span class="n">lst1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'a'</span><span class="p">,</span> <span class="s">'to be'</span><span class="p">],</span> <span class="n">address</span> <span class="ow">is</span> <span class="mi">139715299231864</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lst1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">'to be'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s">"lst1: </span><span class="si">%</span><span class="s">r, address is </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">lst1</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">lst1</span><span class="p">))</span>
<span class="n">lst1</span><span class="p">:</span> <span class="p">[</span><span class="s">'to be'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">'a'</span><span class="p">,</span> <span class="s">'to be'</span><span class="p">],</span> <span class="n">address</span> <span class="ow">is</span> <span class="mi">139715299231864</span>

</code></pre></div> <p>当对列表中的元素进行一些增删改的操作的时候，是不会影响到lst1列表本身的整个列表地址的，只会改变其内部元素的地址引用。可是当我们对于一个列表重新初始化(赋值)的时候，就给lst1这个变量重新赋予了一个地址，覆盖了原本列表的地址，这个时候，lst1列表的内存id就发生了改变。上面这个道理用在所有复杂的数据类型中都是一样的。 <strong>这个原理就解释了最初本例中的list3 为什么会等于list1了，因为append对列表元素的操作不会更改内存地址，所以list1 and list3是一致的</strong></p> <h3 id="2-copy">2. copy</h3> <p>首先，为什么要copy，从python的赋值原理可以看出， 对于list，dict等复杂数据结构来说，赋值等于完全共享资源。然而有时候需要既要保存原始数据，又要对数据进行新的操作，这时就需要copy了。 python的copy模块，有两种方法，一种是普通的copy，也叫浅拷贝；一种是deepcopy，又叫深拷贝。</p> <h4 id="浅拷贝copy">浅拷贝，copy</h4> <p>浅copy，无论多么复杂的数据结构， 浅拷贝只copy一层数据结构。 浅拷贝的形式有几种：</p> <p><strong>切片操作：list_b = list_a[:]<br /> 或者 list_b = [each for each in list_a]<br /> 工厂函数：list_b = list(list_a)<br /> copy函数：list_b = copy.copy(list_a)</strong></p> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">copy</span>
<span class="c">## 浅copy，将lst2 copy成copylst</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lst1</span> <span class="o">=</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lst2</span> <span class="o">=</span> <span class="p">[</span><span class="s">'str1'</span><span class="p">,</span> <span class="s">'str2'</span><span class="p">,</span> <span class="s">'str3'</span><span class="p">,</span> <span class="n">lst1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">copylst</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lst2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s">" The source lst is: "</span><span class="p">,</span> <span class="n">lst2</span>
 <span class="n">The</span> <span class="n">source</span> <span class="n">lst</span> <span class="ow">is</span><span class="p">:</span>  <span class="p">[</span><span class="s">'str1'</span><span class="p">,</span> <span class="s">'str2'</span><span class="p">,</span> <span class="s">'str3'</span><span class="p">,</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s">"The copy list is: "</span><span class="p">,</span> <span class="n">copylst</span>
<span class="n">The</span> <span class="n">copy</span> <span class="nb">list</span> <span class="ow">is</span><span class="p">:</span>  <span class="p">[</span><span class="s">'str1'</span><span class="p">,</span> <span class="s">'str2'</span><span class="p">,</span> <span class="s">'str3'</span><span class="p">,</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">]]</span>

<span class="c">##更改lst2内容，copylst不变</span>
<span class="o">&gt;&gt;&gt;</span><span class="n">lst2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'lst2 str5'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s">" The source lst is: "</span><span class="p">,</span> <span class="n">lst2</span>
 <span class="n">The</span> <span class="n">source</span> <span class="n">lst</span> <span class="ow">is</span><span class="p">:</span>  <span class="p">[</span><span class="s">'str1'</span><span class="p">,</span> <span class="s">'str2'</span><span class="p">,</span> <span class="s">'str3'</span><span class="p">,</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">],</span> <span class="s">'lst2 str5'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s">"The copy list is: "</span><span class="p">,</span> <span class="n">copylst</span>
<span class="n">The</span> <span class="n">copy</span> <span class="nb">list</span> <span class="ow">is</span><span class="p">:</span>  <span class="p">[</span><span class="s">'str1'</span><span class="p">,</span> <span class="s">'str2'</span><span class="p">,</span> <span class="s">'str3'</span><span class="p">,</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">]]</span>

<span class="c">##更改lst1内容，copylst和lst2共同变化，更改copylst的话，也会引起lst1变化</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lst1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">'biubiu'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s">" The source lst is: "</span><span class="p">,</span> <span class="n">lst2</span>
 <span class="n">The</span> <span class="n">source</span> <span class="n">lst</span> <span class="ow">is</span><span class="p">:</span>  <span class="p">[</span><span class="s">'str1'</span><span class="p">,</span> <span class="s">'str2'</span><span class="p">,</span> <span class="s">'str3'</span><span class="p">,</span> <span class="p">[</span><span class="s">'biubiu'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">],</span> <span class="s">'lst2 str5'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s">"The copy list is: "</span><span class="p">,</span> <span class="n">copylst</span>
<span class="n">The</span> <span class="n">copy</span> <span class="nb">list</span> <span class="ow">is</span><span class="p">:</span>  <span class="p">[</span><span class="s">'str1'</span><span class="p">,</span> <span class="s">'str2'</span><span class="p">,</span> <span class="s">'str3'</span><span class="p">,</span> <span class="p">[</span><span class="s">'biubiu'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">]]</span>
</code></pre></div> <p>也就是说， 在字典套字典、列表套字典、字典套列表，列表套列表，以及各种复杂数据结构的嵌套中，浅拷贝只能copy“最外面的一层”数据，使其指向的地址无变化，但是对于复杂的数据，即使地址不变，里面的内容还可能发生变化(如例子里的lst1)，所以这时候，源数据和copy数据就会共同变化。</p> <h4 id="深拷贝deepcopy">深拷贝，deepcopy</h4> <p>deepcopy的原理就是完全开辟一块新的内存空间，无论数据结构有几层，都把其地址中指向的内容层层找到，然后复制下来，放在新的地址里，源数据和目标数据的地址完全隔离，所以也就不会再有关联了。</p> <div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">copy</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lst1</span> <span class="o">=</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lst2</span> <span class="o">=</span> <span class="p">[</span><span class="s">'str1'</span><span class="p">,</span> <span class="s">'str2'</span><span class="p">,</span> <span class="s">'str3'</span><span class="p">,</span> <span class="n">lst1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dcopylst</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">lst2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">lst2</span>
<span class="p">[</span><span class="s">'str1'</span><span class="p">,</span> <span class="s">'str2'</span><span class="p">,</span> <span class="s">'str3'</span><span class="p">,</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">dcopylst</span>
<span class="p">[</span><span class="s">'str1'</span><span class="p">,</span> <span class="s">'str2'</span><span class="p">,</span> <span class="s">'str3'</span><span class="p">,</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">]]</span>

<span class="c">## 无论更改lst2还是lst1，都不会对deepcopy的dcopylst有影响</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lst2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'lst2 biubiubiu'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span><span class="n">lst1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'lst1 bobobo'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">lst2</span>
<span class="p">[</span><span class="s">'str1'</span><span class="p">,</span> <span class="s">'str2'</span><span class="p">,</span> <span class="s">'str3'</span><span class="p">,</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'lst1 bobobo'</span><span class="p">],</span> <span class="s">'lst2 biubiubiu'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">dcopylst</span>
<span class="p">[</span><span class="s">'str1'</span><span class="p">,</span> <span class="s">'str2'</span><span class="p">,</span> <span class="s">'str3'</span><span class="p">,</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">]]</span>

<span class="c">##反之亦然</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dcopylst</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'lst1 bububu'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">dcopylst</span>
<span class="p">[</span><span class="s">'str1'</span><span class="p">,</span> <span class="s">'str2'</span><span class="p">,</span> <span class="s">'str3'</span><span class="p">,</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'lst1 bububu'</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">lst1</span>
<span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'lst1 bobobo'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">lst2</span>
<span class="p">[</span><span class="s">'str1'</span><span class="p">,</span> <span class="s">'str2'</span><span class="p">,</span> <span class="s">'str3'</span><span class="p">,</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'lst1 bobobo'</span><span class="p">],</span> <span class="s">'lst2 biubiubiu'</span><span class="p">]</span>
</code></pre></div> </article> <div class="post-share"> <div class="container"> <a href="https://twitter.com/share?url=http://localhost:4000/2017/04/20/Python-practice-value-and-copy.html&text=Python知识点 -- 变量赋值与深浅copy" target="_blank" class="post-share-icon twitter"></a> <a href="https://www.evernote.com/clip.action?url=http://localhost:4000/2017/04/20/Python-practice-value-and-copy.html&title=Python知识点 -- 变量赋值与深浅copy" target="_blank" class="post-share-icon evernote"></a> <a href="http://service.weibo.com/share/share.php?url=http://localhost:4000/2017/04/20/Python-practice-value-and-copy.html&title=Python知识点 -- 变量赋值与深浅copy" target="_blank" class="post-share-icon weibo"></a> </div> </div> <div class="comment container"> <div id="disqus_thread"> </div> </div> <div class="footer"> <div class="container"> <p class="footer-entry">All content is licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA</a></p> <p class="footer-entry">Buit with <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> and <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll theme</a> • Hosted on <a href="https://pages.github.com/" target="_blank">Github</a></p> </div> </div> </main> <button id="menu" class="open"> <span id="menu-icons"></span> </button> <button id="post-toc-menu"> <span id="post-toc-menu-icons"></span> </button> <div id="post-toc"> <span id="post-toc-title">Table of Contents</span> <ul id="post-toc-ul"></ul> </div> <script src="/assets/js/jquery-2.1.3.min.js"></script> <script src="/assets/js/jquery.pjax.js"></script> <script src="/assets/js/nprogress.js"></script> <script src="/assets/js/main.js"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-54767140-1', 'doing.cool'); ga('send', 'pageview'); </script> </body> </html>
